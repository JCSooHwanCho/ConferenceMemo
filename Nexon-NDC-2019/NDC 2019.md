# NDC 2019

--- 

## 목차

- [1일차](#1%EC%9D%BC%EC%B0%A8)
	- [신입 게임 프로그래머가 되는 법 - 넥슨 채용 프로세스 단계별 분석](#%EC%8B%A0%EC%9E%85-%EA%B2%8C%EC%9E%84-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EA%B0%80-%EB%90%98%EB%8A%94-%EB%B2%95---%EB%84%A5%EC%8A%A8-%EC%B1%84%EC%9A%A9-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8B%A8%EA%B3%84%EB%B3%84-%EB%B6%84%EC%84%9D)
	- [게임플레이 프로그래머의 역할](#%EA%B2%8C%EC%9E%84%ED%94%8C%EB%A0%88%EC%9D%B4-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98-%EC%97%AD%ED%95%A0)
	- [할머니가 들려주신 마비노기 개발전설(키노트)](#%ED%95%A0%EB%A8%B8%EB%8B%88%EA%B0%80-%EB%93%A4%EB%A0%A4%EC%A3%BC%EC%8B%A0-%EB%A7%88%EB%B9%84%EB%85%B8%EA%B8%B0-%EA%B0%9C%EB%B0%9C%EC%A0%84%EC%84%A4%ED%82%A4%EB%85%B8%ED%8A%B8)
	- [<쿠키런, 오븐브레이크> 2년된 게임, 2배로 성장시키기 - 오래 꾸준히, 행복하게 서비스하기](#%EC%BF%A0%ED%82%A4%EB%9F%B0-%EC%98%A4%EB%B8%90%EB%B8%8C%EB%A0%88%EC%9D%B4%ED%81%AC-2%EB%85%84%EB%90%9C-%EA%B2%8C%EC%9E%84-2%EB%B0%B0%EB%A1%9C-%EC%84%B1%EC%9E%A5%EC%8B%9C%ED%82%A4%EA%B8%B0---%EC%98%A4%EB%9E%98-%EA%BE%B8%EC%A4%80%ED%9E%88-%ED%96%89%EB%B3%B5%ED%95%98%EA%B2%8C-%EC%84%9C%EB%B9%84%EC%8A%A4%ED%95%98%EA%B8%B0)
	- [전지적 참견 시점 - 개임개발 PM](#%EC%A0%84%EC%A7%80%EC%A0%81-%EC%B0%B8%EA%B2%AC-%EC%8B%9C%EC%A0%90---%EA%B0%9C%EC%9E%84%EA%B0%9C%EB%B0%9C-pm)
	- [Designing <Path of Exile> to be Played Forever](#designing-path-of-exile-to-be-played-forever)
	- [<달빛조각사> 엘릭서를 이용한 MMORPG 서버 개발](#%EB%8B%AC%EB%B9%9B%EC%A1%B0%EA%B0%81%EC%82%AC-%EC%97%98%EB%A6%AD%EC%84%9C%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-mmorpg-%EC%84%9C%EB%B2%84-%EA%B0%9C%EB%B0%9C)
- [2일차](#2%EC%9D%BC%EC%B0%A8)
	- [블리자드 모든 팀을 위한 플랫폼 중립적인 공용 라이브러리 만들기](#%EB%B8%94%EB%A6%AC%EC%9E%90%EB%93%9C-%EB%AA%A8%EB%93%A0-%ED%8C%80%EC%9D%84-%EC%9C%84%ED%95%9C-%ED%94%8C%EB%9E%AB%ED%8F%BC-%EC%A4%91%EB%A6%BD%EC%A0%81%EC%9D%B8-%EA%B3%B5%EC%9A%A9-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EB%A7%8C%EB%93%A4%EA%B8%B0)
	- [마이크로서비스, 운영하기 좋은 게임 백엔드로의 변화](#%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%9A%B4%EC%98%81%ED%95%98%EA%B8%B0-%EC%A2%8B%EC%9D%80-%EA%B2%8C%EC%9E%84-%EB%B0%B1%EC%97%94%EB%93%9C%EB%A1%9C%EC%9D%98-%EB%B3%80%ED%99%94)
	- [UI는 누가 붙여야 하나? - 디자이너에게 UI돌려주기](#ui%EB%8A%94-%EB%88%84%EA%B0%80-%EB%B6%99%EC%97%AC%EC%95%BC-%ED%95%98%EB%82%98---%EB%94%94%EC%9E%90%EC%9D%B4%EB%84%88%EC%97%90%EA%B2%8C-ui%EB%8F%8C%EB%A0%A4%EC%A3%BC%EA%B8%B0)
	- [AxE 밸런싱 포스트 모템 - 한 개 게임으로 3가지 다른 밸런스를](#axe-%EB%B0%B8%EB%9F%B0%EC%8B%B1-%ED%8F%AC%EC%8A%A4%ED%8A%B8-%EB%AA%A8%ED%85%9C---%ED%95%9C-%EA%B0%9C-%EA%B2%8C%EC%9E%84%EC%9C%BC%EB%A1%9C-3%EA%B0%80%EC%A7%80-%EB%8B%A4%EB%A5%B8-%EB%B0%B8%EB%9F%B0%EC%8A%A4%EB%A5%BC)
	- [게임 서버의 목차, 시작에서 출시까지](#%EA%B2%8C%EC%9E%84-%EC%84%9C%EB%B2%84%EC%9D%98-%EB%AA%A9%EC%B0%A8-%EC%8B%9C%EC%9E%91%EC%97%90%EC%84%9C-%EC%B6%9C%EC%8B%9C%EA%B9%8C%EC%A7%80)
	- [어머님, A/B 테스트를 댁으로 들이십시오](#%EC%96%B4%EB%A8%B8%EB%8B%98-ab-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EB%8C%81%EC%9C%BC%EB%A1%9C-%EB%93%A4%EC%9D%B4%EC%8B%AD%EC%8B%9C%EC%98%A4)
	- [그치만 이렇게 하지 않으면 A/B 테스트 시켜주지 않는걸 - 실시간 A/B 테스트 플랫폼 개발기](#%EA%B7%B8%EC%B9%98%EB%A7%8C-%EC%9D%B4%EB%A0%87%EA%B2%8C-%ED%95%98%EC%A7%80-%EC%95%8A%EC%9C%BC%EB%A9%B4-ab-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%8B%9C%EC%BC%9C%EC%A3%BC%EC%A7%80-%EC%95%8A%EB%8A%94%EA%B1%B8---%EC%8B%A4%EC%8B%9C%EA%B0%84-ab-%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%94%8C%EB%9E%AB%ED%8F%BC-%EA%B0%9C%EB%B0%9C%EA%B8%B0)
	- [<야생의 땅: 듀랑고>, 조직 문화와 라이브 개발 프로세스](#%EC%95%BC%EC%83%9D%EC%9D%98-%EB%95%85-%EB%93%80%EB%9E%91%EA%B3%A0-%EC%A1%B0%EC%A7%81-%EB%AC%B8%ED%99%94%EC%99%80-%EB%9D%BC%EC%9D%B4%EB%B8%8C-%EA%B0%9C%EB%B0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4)
- [3일차](#3%EC%9D%BC%EC%B0%A8)
	- [Interpretable Recommender System 개발 사례연구](#interpretable-recommender-system-%EA%B0%9C%EB%B0%9C-%EC%82%AC%EB%A1%80%EC%97%B0%EA%B5%AC)
	- [SilvervineUE4Lua - UE4에서 Lua 사용하기](#silvervineue4lua---ue4%EC%97%90%EC%84%9C-lua-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0)
	- [<하스스톤> 강화학습 환경 개발기 - 0티어 덱을 만들기 위해 떠나는 모험](#%ED%95%98%EC%8A%A4%EC%8A%A4%ED%86%A4-%EA%B0%95%ED%99%94%ED%95%99%EC%8A%B5-%ED%99%98%EA%B2%BD-%EA%B0%9C%EB%B0%9C%EA%B8%B0---0%ED%8B%B0%EC%96%B4-%EB%8D%B1%EC%9D%84-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EC%9C%84%ED%95%B4-%EB%96%A0%EB%82%98%EB%8A%94-%EB%AA%A8%ED%97%98)
	- [구성원 역량강화 3년 - 조직의 습관은 사업전략과 일치해야 한다](#%EA%B5%AC%EC%84%B1%EC%9B%90-%EC%97%AD%EB%9F%89%EA%B0%95%ED%99%94-3%EB%85%84---%EC%A1%B0%EC%A7%81%EC%9D%98-%EC%8A%B5%EA%B4%80%EC%9D%80-%EC%82%AC%EC%97%85%EC%A0%84%EB%9E%B5%EA%B3%BC-%EC%9D%BC%EC%B9%98%ED%95%B4%EC%95%BC-%ED%95%9C%EB%8B%A4)
	- [실버바인 대기열 서버 설계 리뷰](#%EC%8B%A4%EB%B2%84%EB%B0%94%EC%9D%B8-%EB%8C%80%EA%B8%B0%EC%97%B4-%EC%84%9C%EB%B2%84-%EC%84%A4%EA%B3%84-%EB%A6%AC%EB%B7%B0)
	- [이세계 시나리오 라이터를 위한 스토리텔링 - 유저의 이탈을 막는 매력적인 첫 문장 작성하기](#%EC%9D%B4%EC%84%B8%EA%B3%84-%EC%8B%9C%EB%82%98%EB%A6%AC%EC%98%A4-%EB%9D%BC%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%8A%A4%ED%86%A0%EB%A6%AC%ED%85%94%EB%A7%81---%EC%9C%A0%EC%A0%80%EC%9D%98-%EC%9D%B4%ED%83%88%EC%9D%84-%EB%A7%89%EB%8A%94-%EB%A7%A4%EB%A0%A5%EC%A0%81%EC%9D%B8-%EC%B2%AB-%EB%AC%B8%EC%9E%A5-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0)		- [코드 리뷰 실천 방안 제안](#%EC%BD%94%EB%93%9C-%EB%A6%AC%EB%B7%B0-%EC%8B%A4%EC%B2%9C-%EB%B0%A9%EC%95%88-%EC%A0%9C%EC%95%88)

## 1일차

### 신입 게임 프로그래머가 되는 법 - 넥슨 채용 프로세스 단계별 분석

1. 발표 이유 : 지원자의 질문이 거의 비슷하고 현업에서는 당연한 것들도 지원자 입장에서 알기 힘들다. 따라서 지원자들에게 가이드라인을 주면 회사와 지원자 모두 윈윈할 수 있지 않을까?
2. 넥슨 게임프로그래머 채용 프로세스. 
	1. 서류 심사 : 이력서, 자기소개서, 포트폴리오
		1. 프로젝트 관련 경험 - 자기가 직접 한 것(개인, 팀단위), 회사가 필요한 역량을 가졌는지가 핵심
			* 포트폴리오 : 면접관을 배려하고, 자신이 한 부분이 명확히 하기 위해 여러 도구들(Github, youtube 등)을 이용, 과정에 대한 내용도 필요
		2. 의사결정 경험 : 개인/팀 단위의 의사결정이 회사에서도 똑같이 일어남
		3. 지원자의 관심 분야 : 앞으로 하고 싶은 것, 기술적 관심, 열정적인 취미(게임 개발과 관련이 없어도 괜찮다)
	2. 과제 심사(온라인 코딩 테스트) : 알고리즘 문제 해결력을 보기 위함, 미리 연습하기(NYPC,카카오 공채 코딩 테스트 등)
	3. 직군 면접 : 게임엔진 뿐 아니라 전산학 지식 전반을 폭넓게 요구(그래픽스,서버,  언어, 동시성 처리, DB,알고리즘 등) - 전산학 지식은 절대 유행을 타지 않는다. - 책을 바탕으로 실습하여 자기 것으로 만들기
	4. 팀면접 : 팀의 방향성과 일치하는 지를 평가
3. 준비전략
	1.  직군면접을 소홀히 하지 말라!
	2. 이력서, 포트폴리오, 팀 면접 : 본인이 관심있는 분야를 정해서 설정
	3. 엔진 경험이 중요한가? 직군 면접에는 중요하지 않지만 실무 적응에 도움이 됨
	4. 탈락했다면? 직군 면접에서 탈락했다면 공부를 더 할 것. 포트폴리오 문제가 아니다. 서류나 팀 면접에서 떨어지면 그저 인재상이 맞지 않는 것이므로 너무 걱정 안해도 됨
- - - -

### 게임플레이 프로그래머의 역할

* 게임플레이 프로그래머 : 유저들의 경험과 맞닿아 있는 모든 것들 프로그래밍 하는 사람. 깊이있는 것보다는 빠르게 효율적으로 구현하는 게 중요하다.
	* (게임플레이 프로그래머 관점에서)좋은 프로그래머 : 좋은 코드를 만드는 사람
	* 다양한 컨텐츠가 연관되어 있어 하나에 집중하기 어렵고, 전반적인 코드를 파악해야 하며, 자기가 안 짠 코드도 유지보수 해야한다.
	* 가독성&문서화 - 혼자 하기는 어렵다
	* 답은 **코드리뷰**
* 코드 리뷰의 장점. 
	1. 여러 눈으로 코드를 검증하다.
	2. 리뷰이가 곧 리뷰어이므로 동료를 통해 자신을 점검할 수 있다.
	3. 자발적으로 코드를 다듬게 됨
	4. 코팅 스타일을 자연스럽게 통일하게 되고, 신입의 성장도 빠르게 된다.
* 문서화
	* 목적 : 시스템에 대한 이해도가 낮은 사람이 접근할 수 있게 하기 위해(이러한 목적으로 하면 큰 흐름의 문서로 하면 잘 유지된다)
	* 코드 리뷰를 통해 나온 지적(blame)들이 모두 문서로 기능할 수 있다.
* 그래도 어렵다
	1. 시스템 언제 마련해? -> github, gitlab등(Pull request 이용, 작업의 전후 맥락을 파악할 수 있는 자세한 설명 첨부하기)
		1. 리뷰는 공격적이지 않되 직설적으로 하기.  
		2. 모든 것을 받아들을 필요는 없음
		3. 최종 승인은 PM
	2. 남의 코드 언제 해독해? ->  팀 전체의 코딩 컨벤션을 통일하면 개선될 수 있다.
	3. 리뷰하는 게 힘들지 않나?
		1. MR은 최대한 작은 크기로 유지
		2. MR은 최대한 구체적으로
* 좋은 리뷰
	1. 피드백은 간결,건조
	2. 스탠다드와 취향의 구분은 명확하게
	3. 작은 코멘트는 남기되 미리 Merge를 승인할 것
* 조심할 것
	1. 형식적인 리뷰어 지정이 되지 않도록 조심(잘 안해주는 사람 또는 너무 잘해주는 사람) -> 잘 아는 사람+잘 모르는 사람으로 최소 2명이상
	2. 리뷰어의 집중을 방해하지 말아야 함
	3. 내 작업이 반영되는 속도가 늦어지기 때문에 업무를 투트랙으로 할 것
* 코드 리뷰를 안해봤다면
	1. 오픈 소스 프로젝트에 관심을 가져보자
		* 직접 기여가 좋지만, 리퀘스트 구경도 괜찮다.
	2. 페어 프로그래밍
	3. 소규모 프로젝트에서 적용해보기
* 게임의 측면
	* 현재는 컨텐츠가 너무 다양하기 때문에 사소한 실수가 고객의 이탈을  발생시킨다.
	* 이를 위해 다양한 시도를 하지만, 개발자가 결정할 건 아니다
	* 할 수 있는 건 **일정 지키기**
* 일정을 지키기 위한 노력  
	* 애초에 프로젝트에 대한 이해가 떨어져 예측 실패하는 경우가 많다.
	* 실수를 줄이려면 어떻게 해야할까?
		* 코드리뷰? 작업량을 줄이지는 못한다.
		* 테크니컬 라이팅 : 좋긴 한데, 잘하는 사람이 많지 않다.
		* 정기적으로 짧은 미팅을 가진다
	* 중요한 점
		* 내 작업을 동료가 알게 하라
		* 피드백은 공격이 아니다.
		* 실수를 숨기면 더 큰 피해로 돌아온다. 숨기지 마라
* 게임플레이의 측면. 
	* 채용 공고 : 커뮤니케이션을 잘하는 사람 요구
	* 게임 프로그래머의 역할 : 게임 디자이너에게 요구를 받고 만들고 피드백 받는다.
	* 게임 디자이너와 게임 개발자는 관점이 정 반대인 경우가 많아 충돌이 많다.
		* 일단 해보고 안되면 거절한다.
		* 역으로 제안하여 결정권을 넘긴다.
	* 게임 디자이너가 가장 알기 힘든 부분을 가장 잘 아는 것이 프로그래머이므로, 디자인의 완결성을 높이는 것이 프로그래머의 의무이다.
	* 참견이 아닌 피드백, 외주가 아닌 협력을 해야한다.
	* 디자인 문서에서 모호한 부분을 명확하게 해줘야 한다.
	* 조심해야 할 부분
		1. 내가 게임 디자인 하는 거 아니다(월권 금지)
		2. 단순한 거절이 되지 않도록
		3. 공격적 표현 자제 -> 디자이너를 소극적으로 만들게 됨
	* 테크니컬 디자이너(비공식)이라고 할 수 있다.  별도로 해당 직군이 있지 않는 이상 게임플레이 프로그래머가 가장 적합하다.
	* 프로그래머가 아닌 팀의 요청을 받았을 때, 프로그래머의 언어가 아닌 다른 언어로 소통할 수 있어야 한다.
* 게임 플레이 프로그래머 : 프로그래머  + 게임에 대한 이해 + 비프로그래머와의 소통 + 동료 프로그래머와의 소통
* 기술적으로는 점점 자동화 되고 있는 부분이 많기 때문에 소통면에서 스페셜리스트가 되어야 한다.
- - - -
### 할머니가 들려주신 마비노기 개발전설(키노트)
* 게임업계에서 옛날 이야기를 듣기 어렵다.
* 외국은 옛날 게임을 비교적 쉽게 찾고 이야기를 들을 기회도 많으나, 국내 게임은 패키지도 적고, 온라인과 모바일로 넘어가며 점점 기록을 남기기 어려움
	* 마비노기는 매우 운 좋은 케이스로 옛 자료, 옛 사람들이 많이 남음
* 더 많은 게임들이 많은 이야기를 남기기를
* BBS를 운영하면서, 열심히 활동은 하나 먼저 사람들에게 다가가지는 않는 사람들을 발견
	* 게임의 목적 = 사람들이 신기할 만한 장난감을 가지고 사람들의 주목을 끌고, 사람들과 친해지는 것. 이 신기할 만한 것을 구하는 과정이 재밌으면 더 좋고!
* 새로운 프로젝트를 시작하는 것은 쉽지 않다. 이미 검증된 사람에게 기회를 주려하기 때문에 신입이 기회 잡기 쉽지 않음
* 튈만한 기획서로 기회를 잡음 - 하지만 문제는 여전하다. 
	* 기술적인 불안 요소 - 이러한 게 필요한데 관련 경험이 없다. 
	* 3D - 친구가 만들던 3D 엔진을 헐값에 구입(후에 다 갈아엎음)후 빠르게 프로토타입 개발, 이후에는 DirectX7 시절부터 자체적으로 카툰렌더링, 라이팅, 색조 컨트롤, 버텍스 섀도우&페인팅 등을 적용 -> 자체적으로 개발하니 이후 하드웨어의 발전을 따라가기 어려운 단점이 있었음
	* DB - file기반 서버에서 갈아탔다. 그 당시에는 너무 느려서 자체적 튜닝 필요
* 게임에서 다정함을 느낄 수는 없을까란 생각을 게임에 녹여내고자 
* 기존의 턴제 전투에서 벗어난 가위바위보 전투 시스템 기획 - 사람들은 여전히 턴제로 여겼지만… -> 확장성이 좀 떨어지는 단점이 있음
* MMORPG에서 스토리는 모험 -> 라이브 서비스 하면서 스토리 업데이트를 중단한 것을 후회
* 음악은 텍스트 기반 악보로 배포, 연주는 MIDI로 -> 합주등의 컨텐츠는 100% 유저들의 작품
* 아바타와 일체감을 느끼게 하기 위해 노력
* 애니메이션은 절제할 곳은 절제, 과장할 곳은 과장하기 -> 전통적 애니메이션 참고
* 게임의 모든 부분에서 비율을 의식하고 해당 요소들을 조정했다.
* 실제 게임을 이용한 미디어화
* 사내 전체에 게임의 개발 상황을 지속적으로 공유
* 유저와 최대한 가까이 지내려 노력
* 어려운 상황 가운데에서도, 누군가가 이 게임을 사랑한다는 생각이 팀에게 동력과 책임을 얻게 만듬
* 하지만 지나친 근무량으로 번아웃을 경험 -> 디렉터마저!
*  개발팀과 라이브팀의 분리 결정
* 마비노기 - 사내의 유일무이한 완전한 개발 기록
* 모바일화 - 마비노기의 이야기를 미래로 연결하는 역할
* 한국 게임은 늘 똑같다, 발전이 없다 - 과거가 너무 빨리 유실되기 때문일 수도 있다.
* 한국 게임들은 대부분이 점으로만 남거나 아예 사라저버렸다. 이 점들이 선으로 이어져 미래로 나아가기를…
- - - -

### <쿠키런, 오븐브레이크> 2년된 게임, 2배로 성장시키기 - 오래 꾸준히, 행복하게 서비스하기

* IP 좋으니까 잘 되겠지 : IP에 기대도 재미없으면 떠난다.
* 오늘의 주제 : **2주년 2배 성장하기**
* 17년은 힘들었는데 2018년은 유지 vs 성장 -> 2배 성장하기!
	* 전제 :
		1. 유저는 굉장히 현명하다.
		2. 컨텐츠와 과금은 무조건 함께간다
		3. 언급된 실험들은 여러 고민들의 산물이다.
	* 서비스 관점 
		* MAU(월간 활성화 유저수 * PUR(과금 유저 비율) * ARPPU(결제유저 평균 결제금액) = REVENUE = 양질의 컨텐츠를 만드는 근간
		* 다만, 파레토의 법칙이 업계에 만연하여, ARPPU를 상승시키는 전략들이 사용됨 - 과금벽을 치는 효과로 과금유저의 양극화를 가져오고 게임을 빨리 노후화시킴  -> 파레토의 법칙은 캐주얼 뿐 아니라 코어한 게임들에서도 이 법칙은 깨지고 있다.
		* PUR을 올리는 것이 건강한 서비스를 유지하기 위해 중요하다. -> PUR에 더 우선순위를 둠
		* 실험 1(쿠키 훈련소) : 기존 컨텐츠와 관련있는 의미있는 컨텐츠를 추가하면 어떤 상관관계가 있을가? -> 성공!(PUR 급상승), 향후 컨텐츠 업데이트의 핵심 시스템으로 발돋움
		* 실험2(대규모 업데이트) : 양질의 컨텐츠를 많이 제공하면 유저수도 높아지고 PUR도 높아지지 않을까?  -> 순간적으로 사람이 몰려 서버 다운, 새로운 컨텐츠에 적응에 어려움 겪음, 컨텐츠 양에 비해 상승한 수입은 적었음, 그래도 새로운 컨텐츠에는 긍정적 피드백
		* 실험3(초저과금 상품) : 엄청난 효율의 초저과금 상품을 한정된 수량만 판매 -> 최고 PUR갱신, 매출 순위도 최고조, 다만 너무 자주쓰면 기본 상품이 안팔리게 됨
		* 실험4(마법사들의 도시) : 스토리적인 푸시 + 기간 한정 컨텐츠 + 꾸미기 한정(두려움 : 이미 얻은 것만 얻고 빠지면 어쩌지?) -> Long-tail 구매가 확연히 개선, 상품획득한 유저가 Complete을 위해 추가 구매하는 경우가 많음
		* 다 하는 거 아냐? : Live Ops에서 기본적인 기법이나, 가격적 측면에서의 과감한 결단을 하지 못하는 겨우가 많다.
		* 이외에도 여러 실험들이 있지만, 결국 이런 것들은 사람이 만드는 것이다.
	* 개인 및 팀의 관점 
		* 라이브 서비스 개발자의 악순환 : 라이브라 긴장 -> 주변 동료들이 실수할 때 짜증 -> 서로 눈치 -> 서로 불편해짐 -> 문제를 서로 이야기하지 않아 문제 방치 -> 서비스 질 악화 -> 성장과 도전 상실 -> 현자타임 -> 퇴사
		* 좋은 전략도 중요하지만, 실제 구성원들의 긍정성이 제일 중요 -> 구성원들의 상태에 따라 실험의 결과에 큰 영향을 미친다
		* 부정적인 순환 끊기, 개인의 긍정을 넘어서 팀의 긍정성을 문화로 만들기 
		* “비판은 직원을 성장시키지 않는다. 직원이 잘하는 부분에 집중하라” -> 먼저 개인이 잘하는 것에 집중(구체적으로), 그 뒤에 부족한 부분을 채워넣기
		* 조직의 리더의 경우는 먼저 스스로 잘못한 것에 대해 인정하는 모습을 구성원들에게 보여줄  -> 그래야 팀원들이 인정하고 개선하는 선순환이 일어나고, 문화로 정착해야 새로오는 동료들도 일일이 설득하는 비용이 줄어듬
		* 결론 : **작년대비 업무효율이 큰 폭으로 증가함, 팀 이탈율도 현저히 낮아짐** -> 매출에도 큰 영향을 미침
	* 교훈  
		1. 라이브 서비스의 건강한 지속성을 위한 고민이 첫번째다.
		2. 매출보다 더 중요한 것은 컨텐츠다.
		3. 새로운 실험을 할 때는 기본적인 가설 설정 및 회고는 필수이다.
		4. 서비스 개선은 종합적으로 이루어지는 것이다. 한가지 관점만 고집하지 마라.
		5. 과거부터 집착하고 있던 가정이 잘못되어 있는지 점검하자
		6. 개인의 긍정성을 팀의 문화로 변화시키는 선순환이 중요하다.
		7. 동료와 유저들 모두에게 감사함으로 성장하기
	
* 좀 더 넓은 곳에서 많은 분들에게 오랫동안 사랑받기
- - - -

### 전지적 참견 시점 - 개임개발 PM

* 개임개발PM : 게임이 완성되게, 일이 진행되게 하는 것 -> 아무리 좋아도 출시/완성되지 않으면 소용없다
* 개임 개발PM은 개발에 관련된 모든 걸 하지만, 오늘은 마일스톤과 문서화에 대해 이야기한다.
* 우리는 모두 계획을 세우지만, 지켜지는 경우는 적다.
	* 호프스태터의 법칙 : 일을 마치는 데 예상한 것보다 더 오랜 시간이 걸리는 현상 -> 계획오류: 계획을 세울 때 낙관적인 추정으로 인해 계획한 시간을 지키지 못하는 현상(낙관적 편향)
	* 소망적 사고에 의해 낙관적 편향이 일어난다.
	* 다양한 직군과 다양한 이해관계의 충돌로 인해 예상보다 태스크가 증폭되고, 계획은 어그러진다.
* PM != 보스, PM은 연예인 매니저에 가깝다. -> 프로젝트가 한정된 시간에 최대의 완성도를 낼 수 있게 만드는 것
* PM의 업무 프로세스 : (기획&디자인  -> 담당자 지정 / 계획수립 -> 개발진행 -> 배포 및 후속조치) 의 반복
	1. 기획&디자인
		* 문서 작성 확인 : 아이디어 ->  기획문서 -> 실무자
		* 우선 순위 정하기 : 시급성에 따라 일을 분류하여, 한정된 시간에 필요한 일부터 진행되도록 함
		* WBS(Work Breakdown Structure)로 업무를 분할하고 구조화함
	2. 담당자 지정 / 계획 수립
		* 일감회의 
			* 문서가 없는 일은 하지 않는다가 원칙
			* 해당 문서로 일의 규모가 파악 가능해야한다
			* 개발 파트장은 해당 문서를 읽고 회의에 참여(검토)
			* 검토 과정에서 작업일을 산정
		* 버퍼 확보 : 버퍼의 역할은 다양하고, 태스크의 절반 정도 잡아야 한다.
		* 문서화 : 커뮤니케이션 비용을 줄여주는 효과가 있다
	3. 개발진행 
		* 체크하기 : 감시가 아니라 길라잡이 역할임을 계속 주지시켜야 한다.
		* 이삭 줍기 : 프로젝트 중 모종의 이유로 진행되지 않는 사소한 일들을 진행되게 하는 것
	4. 배포 및 후속조치
			* 패치 노트 작성
			* 점검 진행
			* 후속 조치 -> 인프라 수치에 기반
* PM의 역할  
	1. 상기시키기(Reminding) 
		* 다양한 협업 툴 활용(Notion,Asana, jira+Confluence, trello, WorkFlowy)
	2. 분배하기(Load Balancing) 
		*c러닝 코스트가 높아서 생기는 병목 ,사고로 생기는 병목
		* PM이 미리 파악하고 이에 대해 조치를 취해야 함
	3. 전달하기(Messaging)
		* 변경사항에 대한 밀도 높은 정보 전달 - 바뀌게 된 이유, 어떻게 바뀌는지, 업무의 히스토리 등
		* 언제나 중요한 문서화
	4. 결정돕기(Decision Making)
* PM은 결정을 하는 것보다는 사람들이 결정하도록 이끄는 역할이다.
* 개발능력이 있으면 좋은데 너무 많을 필요는 없다.
* PM이 가져야 될 역량은?
	1. 맥락적 이해 능력
		* 상황을 구조화하여 원인이 무엇인지 파악하기(왜?라는 질문으로 근본적 원인을 찾아가라)
	2. 새로운 지식 습득 -
		* 다양한 직군과 일하기 때문에 Generalist가 되어야 한다. 
		* 주변의 Specialist들에게 물어보자
	3. 신뢰 주기
		* 본의 아니게 약속을 어기게 될 수는 있지만, 그 이후의 행동이 중요하다. 못 지키게 된 이유를 확실하게 전달하라.
		* 중간중간에 지속적인 소통을 해나가라
	4. 타협하기
		* 원해서 생기는 변수는 없다
		* 소프트 스킬 : 정성적인 능력이지만 매우 중요
		* 너무 타협하다 보면 시스템이 무용지물이 되고, 구두로 일이 진행되게 된다.
* **잘 기록하고, 잘 정리하고, 잘 결정하자**
- - - -

### Designing <Path of Exile> to be Played Forever

* PvE게임이 오랜 시간동안 유저기반을 성장시키기란 어렵다 -> PvE게임의 컨텐츠는 사용자 자체가 컨텐츠인 PvP에 비해 금방 바닥나기 때문
* 롤모델 : 디아블로2 -> 어떻게 그렇게 많은 사람들이 아직까지도 하고 있을까?
	1. 강력한 액션 전투
	2. 랜덤한 레벨
	3. 랜덤한 아이템
	4. 안정적인 온라인 경제
	5. 깊이 있는 캐릭터 커스터마이즈  
* 디아블로 2보다 잘 할수 있는 것 : **주 단위의 패치**
* 첫 오픈 베타 성적 : 7만명 동접, 150만명의 가입자수 -> 하지만 동접이 점점 떨어짐
* 이를 해결하기 위한 여러 실험
	1. 경제 리셋 및 새 컨텐츠 추가(리그) -> 여기서 주 단위 컨텐츠 패치 포기(3주 단위)
	2. 스팀 릴리즈 : 동접 급상승, 다만 또 떨어짐
	3. 대규모 확장팩 : 확장팩 출시 때마다 동접 상승, 그러나 또 떨어진다.
	4. 리그 간격을 1달로 맞춤 : 효과 없음,
	* 새 컨텐츠를 내는 것은 지속가능한 발전을 주지 못한다.
* 배운 점  
	* 경제 리셋은 효과가 있다.
	* 조그만 컨텐츠 추가는 마케팅 효과가 적어 효과가 적다. -> 대규모 컨텐츠 추가가 더 효과적이다.
	* 리그 중간에 밸런스 패치 -> 오히려 유저들에게 방해가 됨
	* 예측 가능한 업데이트 스케쥴이 중요하다 (13주(3개월) 단위로 Tick-Tock)
* **유저들이 게임을 그만두더라도 돌아올 계획을 가지고 그만두게 만들어야 한다.** 
* 초기에 예측 불가능한 동접자 추이가 점점 예측 가능해지게 된다.
* 업데이트에서 무엇을 하는가?  -> 다양한 유저의 다양한 수요를 충족 
	* 조금씩 줄거리를 풀어냄
	* 새로운 게임 방식을 시도함
	* 새로운 목표를 부여해 줌(게임안의 게임)
	* 최상위 실력자 1%의 컨텐츠 제작 : 나머지 유저들의 도전의식을 부르고, 스트리밍 컨텐츠로써의 역할을 함
	* 다양한 아이템 메커니즘 추가
	* 크래프팅과 거래를 통해 경제적 수요 달성
	* 리밸런싱을 통해 새로운 시도를 추구하게 함
	* 새로운 스킬 및 아이템 도입
* 13주 사이클을 어떻게 달성하는가?
	* 문제해결 1주
	* 컨셉 도입 및 검증 2~3주
	* 출시 3주 전 마케팅 해야 함
	* 언론홍보를 위한 자료 만드는 데1주 소요
	* 실제 개발할 수 있는 기간은 4주뿐! 
		* Fast Prototyping 절실  -> 하지만 아무리 해도 쉽지않다.
		* 자동화된 레벨 생성 ->간단한 도식만으로 자동으로 레벨을 만들고 엔진으로 렌더링, 완전 자동화 된 레벨 제작으로 더 빠르게 여러 레벨을 만들 수 있고 추가 요소를 넣기도 용이하다.
		* 여러 랜덤 요소의 중첩
		* 에셋의 재활용 -> 에셋의 껍데기와 조합을 바꿔 사용
		* 컨텐츠의 재활용
		* 작업량 타협 -> 작업량과 품질은 선형이 아니다. 절반 정도의 일로 약 90%의 완성도를 얻어낼 수 있다.
	* 주의할 점
		* 파이프라인 형태의 출시 계획 X -> 유저 반응에 쉽게 대응할 수 없다. 사전에 너무 많이 계획하지 마라.
		* 컨텐츠를 너무 미루지 마라 -> 지금 가장 할 수 있는 최고의 게임을 만들어라
		* 너무 계획적으로 컨텐츠를 만들지 마라 -> 후에 재사용할 수 있어야 한다.
* 결론 : 유저들은 게임을 하지 않더라도 웹사이트를 방문하며, 계속 커뮤니티에 참여한다. 그들이 돌아올 수 있도록 만들어야만 한다.
* etc
	* 아이디어 내기 : 따로 따로 보면 별로인 아이디어도 조합하다보면 좋은 것들이 나올 것이다.

- - - -

### <달빛조각사> 엘릭서를 이용한 MMORPG 서버 개발

* 엘릭서 - 2011년에 만들어짐,함수형 언어 -> 생소하다
* 함수형 언어의 특징 3가지
	1. 데이터 구조 
		* 리스트, 튜플, 맵
		* 변수값은 불변
		* 데이터 상태를 함수의 입/출력으로만 제어
	2. 순수성(참조 투명성 
	3. 재귀 - 지저분해질수도 있지만 이를 간단한 형태로 바꿀 수 있도록 지원, 꼬리재귀 최적화 지원
* Eilxir 특징
	1. 최신(?) 기능들 지원
		1. 빌드툴 mix
		2. 하위 프로젝트 관리 툴  umbrella
		3. include없다. 하위 클래스 참조 추가 만으로 지원 가능
		4. 파이프 연산자 지원
		5. 패턴매칭
		6. 자동 코드 포맷팅 - 컨벤션 강제
		7. 컴파일 속도 빠름
	2. Erlang VM 기반으로, Erlang의 특징을 많이 가져감
		1. 경량화된 프로세스
		2. 액터 기반 프로세스 -> 프로세스간 메세지 통신
		3. 비즈니스 로직은  잘게 나누어 처리
		4. 장애 허용 -> 프로세스가 죽게 놔두고, 그 프로세스를 다시 살리는 슈퍼바이저가 존재
			* 오히려 빈도수가 드문 예외 처리하겠다고 코드 늘리는 게 더 유지보수 어렵게 하고 무결성을 깨지게 한다.
	3. ETS 지원  
		* Erlang OTP상에서 지원
		* 튜플 기반
		* 상수 시간의 입출력 보장
	4. 코드상에서 유닛 테스트를 작성 가능
* 러닝 커브
	1. 함수형 언어   
	2. 매크로
	3. 얼랭
* Elixir 서버 구조 설계
	* 프로세스 나누는 기준
		1. 프로세스간 인터렉션 적음
		2. ???
		3. ???(못 적음)
	* 유저 프로세스 : 프로세스와 1대1 대응
	* 몬스터 : 유저와 동일하나 지역별로 관리
	* 콘텐츠로 프로세스 id를 찾는 매커니즘 필요 
	* 병목지점 
		1. 캐릭터간의 인터렉션을 중앙 프로세스에서의 직접 처리하니 부하가 너무 크다 -> 각 프로세스에서 처리하도록 액터 모델을 극대화
			* 각자의 데이터 변경 책임은 각 프로세스 자신에게 있다. 
		2. 지역관리 프로세스에서 브로드캐스팅 횟수가 너무 많다. -> 브로트캐스트 리스트를 유지해 이미 받은 것들은 무시
	* 성능, 안정성, 생산성 모두 잡음
* Elixir 그 외
	1. 개발에서 배포까지 OTP를 통해 처리
	2. Elixir자체가 매크로로 정의되어 있어, Macro Meta Programming 가능
	3. 인터렉티브 모드 지원(iex)
	4. 동적 코드 업로드, 실시간 코드 패치 가능
	5. 분산 서버 구성이 간편해짐
* Elixir 도입 결과
	* 아직은 마이너 매년 컨퍼런스 개최, 반년 주기 메이저 업데이트 -> 발전 가능성 크다
	* 느슨한 타입 검사로 인해  런타임 에러 발생 가능성 있음 -> 사이드 이펙트가 없기 때문에 조금만 돌려봐도 쉽게 잡아낼 수 있다. -> 유닛 테스트로 커버리지를 높여야 한다.
	* 생산성 증가
	* 클라이언트 없이도 빠른 이터레이션 가능
	* 메모리 문제 해결(릭 제외), 에러 재현 쉽고 타이밍 문제 적음
* 서버 개발시 고려할 사항
	1. 많은 프로세스를 만든다는 가정하에 접근, 설계
	2. 프로세스를 어떻게 나눌지 결정
	3. 논리적으로 고립될 수 있고 독립된 로직
	4. 프로세스가 헤비 로드를 가지지 않도록 분배
	5. 프로세스간 메시지 Compact하게 유지
*  멀티코어 시대에 Free Lunch는 끝났다지만, Elixir가 그 대안이 될 수 있을 듯 하다
- - - -

## 2일차

###  블리자드 모든 팀을 위한 플랫폼 중립적인 공용 라이브러리 만들기

* 기존 커리어는 윈도우 전용 개발자, 블리자드 입사 후 멀티 플랫폼 런처를 개발해야 했다.
	* 2개월 뒤,  Window_Mac_Linux 를 지원하는 UI라이브러리를 개발하여 내놓게 되었다.
	* 이후에도 충분히 공유되고 개발되어 여러 프로젝트의 주요 요소로 활용됨
	* 게임은 점점 다양해지고, 플랫폼도 더욱 늘어만 간다.
* 블리자드 문화
	1. 직접 만든 프레임워크 선호
	2. 품질을 최우선으로 함
* 하지만 시장은 기다려 주지 않는다.
	* 더 빠른 개발, 더 많은 공유기술, 더 많은 자동화, 더 많은 데이터 -> **이식성, 재활용성, 높은 품질**이 요구됨
* 텔레매트리 시스템의 SDK 개발 경험
	1. 이식성 문제 : 다양한 플랫폼, 다양한 버전 요구, 자주 쓰는 조합만 CI 구성하려고 해도 10개가 넘는다.  
		* 특정 플랫폼에 종속적인 라이브러리를 쓰는 순간 이식성은 날아간다.
		* 표준을 따라야 한다.(Posix, C++ 표준)
		* 외부에 노출된 인터페이스를 잘 설계함으로, 플랫폼별 구현체를 쉽게 만들 수 있고 새로운 플랫폼을 추가하기도 용이하다(구현은 더러워질 수 있지만…)
		* Header : 분할 컴파일을 지원하기 위해 나온 것, Interface와 Implementation을 분리한다.
		* 플랫폼을 기능들의 집합으로 본다면
			1. 같은 기능 - 동작과 결과가 같다.
			2. 없는 기능 - 다른 플랫폼에서 지원하지 않는다.
			3. 다른 기능 - 결과는 같은데 내부 동작이 다르다. -> 얘 때문에 Wrapper가 필요하다.
		* 	예시 : Unity용 텔레메트리 SDK 
			* 원래 C#이 있으니 쉽게 하겠지 했는데 Unity 플랫폼에 있는 기능들만 써야되서 쉽지 않더라
			* Wrapper를 만들어서 해결
		* Back to Basics
			1. 좋은 API를 설계하는 스킬
			2. Public과 Private 나누기
			3. 오픈 소스 및 다양한 API연구
			4. 다양한 플랫폼 개발 경험
			5. 이른 시도 / 빠른 실패/ 지속적인 시도
	2. 재활용성 : 다른 사람이 이걸 가져가서 다시 사용할 수 있느냐
		1. 개방성 높이기
		2. 표준화하기
		3. **자동화**
			* 코딩 스타일 통일 : cpp-lint, clang-format
			* 프로젝트 자동 생성 : Cmake,premake(Lua이용)
			* 소스 퀄리티 체크(static analysis) : Coverity,SonarQube, VS2019
			* CI / BVT(빌드 확인 테스트) / SA(정적 분석) / LT / CD / DG(문서자동생성) 등 -> 자동화 할 수 있는 만큼 자동화 해야 한다.
			* 단, 자동화 시스템은 그 자체가 안정적이여야 한다.
	3. 공유하기  
		* NIH Syndrome : 직접 만들어쓰는 걸 더 선호하고 타인의 것을 배척하는 현상 -> 남이 뭐하는지 모르고, 알고 싶어하지도 않는다.
		* 신뢰를 쌓아야 우리의 기술을 퍼트릴 수 있다
			* 도움을 주라
			* 첫인상이 좋아야 한다.
		* 팀의 프로세스(알고리즘)이 안 좋으면, 아무리 자원을 투입해도 소용없다.
	* 우리가 만드는 것은 기술이지만, 만드는 것도 쓰는 것도 결국 사람이 한다.
	* 좋은 사람이 좋은 조직을 만드는가, 좋은 조직이 좋은 사람을 만드는가? -> 닭이 먼저냐 달걀이 먼저냐
	* Conway’s Law : 조직의 구조와 시스템의 아키텍쳐는 닮는다
	* 성당 모델과 시장 모델
		1. 성당 모델 : 소수의 개발자가 어느 정도 완성된 코드를 내보낸다
		2. 시장 모델 : 다수의 개발자가 오픈된 코드를 발전시킨다.
* 결론  
	1. 다양한 플랫폼, 빠른 개발은 필수
	2. 잘 설계, 잘 정리, 최대한 자동화 하자
	3. Do the Right Thing, 일단 시작해라
	4. 일단 한 부분이라도 집중적으로 개선해보자! -> 기술, 사람, 커뮤니케이션, 조직, 평가

- - - -

### 마이크로서비스, 운영하기 좋은 게임 백엔드로의 변화
* (레이어드)모놀리딕 vs 마이크로 서버 -> 물론 이전부터 잘 쪼갠 사람도 있다.
* 타 업계에서의 마이크로서비스 장점 -> 게임 업계에는 잘 안맞는 이야기
		1. 도메인 주도 개발
		2. 언어 사용 자유로움
		3. 용도에 맞는 여러 데이터베이스 사용 가능
		4. 만들기 쉽고 유지하기 쉽고
	* 게임업계에서의 마이크로서비스는 클라우드 환경에서의 운영 개선에 의의가 있다.
	* 운영하기 좋은 백엔드는?
		1. 적은 다운타임 혹은 없는 다운타임
		2. Fail-resilient
		3. Scale-out,Scale-in이 쉽다
		4. 배포가 쉽다
* 마이크로서비시스 구현 시 고려사항
	1. API Gateway : 로드 밸런싱, 테스트 쉬운 프로토콜, 인증서 관리 편리(Https)
	2. 데이터베이스 선택 : 어느정도 복잡도 관리가 필요
	3. CAP : (Availability를 버릴 수는 없으니)보통 Consistency가 희생이 되지만, 그걸 보완하기 위해 트랜잭션과 Eventual Consistency를 구현 -> 역시 복잡도와의 Trade-off고려
	4. CCU(Concurrent User) 집계의 곤란함(Rest API로 구현되기 때문에) -  WebSocket 등 적용
* DevOps 경험 사례
	* 컨테이너 사용의 장단점
		* 장점 :  VM보다 빠름, 자원 사용 문제 없음
		* 단점: 서비스간 전환이 빠르지 않으면 안쓰니만 못하다.
	* 오케스트레이션 시스템(요새는 거의 쿠버네티스로 통일) 필요성 : 잘개 쪼갠 서비스 -> 늘어가는 컨테이너 -> 늘어나는 빌드 스텝, 관리할 컨테이너 수 증가 -> 트러블 슈팅 곤란함
		* 배포, 스케일링, 모니터링 지원
		* 환경 찍어내기 쉽니요? : Yes, 다만 설정 관리 잘해야 된다. 
			* 기능 증가 = 설정 부분의 증가
			* 항상 설정의 품질 관리가 중요하다.
		* 스케일링이 쉽나요? : 네, 근데 리소스 배정이나 오토 스케일링은 별도 문제 -> 경험적인 데이터가 필요하다
	* 트러블 슈팅
		* 로그 관리 및 검색 - Kibana,Splunk,AWS X-Ray
		* 모니터링 : cloud watch, grafana, datalog, zabbix
	* 바꿀만 한 가 부터…
		* 대격변 vs 점진적 변화 -> 점진적으로, 대격변은 리스크가 너무 크니까
		* 하이브리드 아키텍처의 필요성
* 오래된 게임 백엔드 마이크로서비시스로 전환하기 -> containerization 부터 해보자
* 결론 : 유행하는 것들 잘 끌어다 쓰는 게 멋있어보이지만, 골치 아파지는 경우가 많다. 오버엔지니어링을 피해서 즐겁게 개발하자.
- - - -

### UI는 누가 붙여야 하나? - 디자이너에게 UI돌려주기
* UI 개발 공정의 발전  : 하드코딩 -> XML -> 유니티/언리얼 -> +a
*기존의  UI 제작 공정 : UX기획(기획자) -> 리소스 제작(아티스트)  -> 기능구현,UI적용(프로그래머) -> 확인(기획자,QA팀)
* 기존의 프로세스로 인해 불만들이 쌓인다.
	* 프로그래머의 불만   
		1. 내가 만든 리소스가 아니라 이해하기 어렵다
		2. 작은 수정에도 아티스트와 소통해야하는 난점이 있다
	* 아티스트의 불만
		1. 생각했던 것과 적용된 결과가 다르다.
		2. 책임만 있고 권한은 없다
	* 기획자의 불만
		1. 기한 추정이 어렵다
		2. 컨셉 수정이 필요해도 쉽사리 수정이 어렵다
* 그러면 설계도(목업)을 정확히 작성하면 되지 않나?  
	1. 	포토샵과 게임엔진에서 표현되는 결과물이 같지 않음(좌표 및 폰트 크기,9-slice 계산법, 안티앨리어싱 강도 등)
	2. 상대 좌표계와 절대 좌표계를 혼용하면 안되는데 어느 하나에 맞추려면 추가적인 계산이 필요하고, 이 과정에서 눈에 잘 안띄는 부분은 놓치기 쉬움
	3. 설계도 수정이 너무 잦으면 설계도 대신 구두로 작업이 이루어 진다.
* 새로운 UI 제작 프로세스 : 기능 구현과 리소스 제작,UI적용을 병렬적으로 하고, UI적용은 아티스트가 한다. 
	* 아티스트와 프로그래머간의 의존성을 낮추는 게 핵심! -> Continuous UI Design
* 필요한 것
	1. 프로그래머가 아티스트 없이도 목업을 할 수 있어야 한다.
	2. 아티스트가 프로그래머 없이도  UI적용을 할 수 있어야 한다.
* UI의 세가지 기능
	1. Presentation - 필요한 정보를 유저들에게 노출시키는 기능(사용자 입력에 대한 처리 제외)
	2. Navigation - 데이터 변경이 필요하지 않은 사용자 입력에 대해 처리하는 기능
	3. Operation - 사용자 입력에 따른 데이터 변화를 기록하는 기능-> 아티스트가 할 수 없는 부분
* 아티스트가 Presentation,Navigation을 할 수 있다면 UI적용을 할 수 있다.
* CUD를 위한 구현
	1. Bidirectional Data Binding : UI와  데이터가 서로 연결되어 서로가 변할 때 마다 갱신 된다 -> 중간에서 Proxy를 만들어 이를 중계
		* 프로그래머는 간이 viewer로 Proxy 값을 확인하며 작업하면 UI 리소스 전혀 없이도 작업을 마칠 수 있음
		* 아티스트는 UI의 작동여부를 직관적으로 알 수 있음
	2. View Data Layer : 1번에서 언급한 그 Proxy
	3. UI State Machine : UI 상태를 코드를 실행하지 않더라도 바꿀 수 있게 함으로 아티스트들이 쉽게 테스트 가능
	4. External Interface for custom function :  Proxy에서 사용할 수 있도록 등록하는 기능
	5. Navigation Event Hooker : 아티스트의  Navigation을 프로그래머가 감지하여 특정 동작을 실행시킬 수  있는 기능
* 결과  
	1. 프로그래머
		* 서버프로그래머 느낌
		* 내가 모르는 사이에 UI가 바뀌어 있다
	2. 아티스트
		* 책임과 권한을 동시에 가짐
		* 여러 시도 가능
	3. 기획자
		* 책임 소재가 명확해짐
* 언리얼엔진에서의 적용
	* 모든 로직은 C++로 보내고, 아티스트는 WBP(Widget BluePrint)만 사용

- - - -

### AxE 밸런싱 포스트 모템 - 한 개 게임으로 3가지 다른 밸런스를
* AxE 의 기본 컨셉  : 끊임없는 전투
* 국가별 밸런스를 다르게 하는 이유
	1. 국가 별로 선보일 컨텐츠가 다르다(문화적, 법률적 이유) -> 컨텐츠 변경은 곧 밸런스 변경
	2. 국가 별로 익숙한 게임이 다르다 -> 유저들의 플레이 감각이 국가별로 다르다
	3. 국가 별로 핵심 상품이 다르다. -> BM과 밸런스는 같은 운명
* AxE의 방향성
	1. 전투를 재밌게 -> 대부분의 컨텐츠가 PK와 연관되었기 때문에
	2. 전투를 쉽게 한다 -> 모바일의 한계 때문에
	3. 성장하는 맛이 나도록 한다.
* 밸런싱 방법
	1. 유저의 최대 능력치 설정
	2. 능력치와 종류의 공급 비율 설정
	3. 레벨, 등급에 따른 성장 수치 계산
	4. **반복 테스트**
		* 특정 요소에 너무 과하게 능력치가 풀리지 않았나?
		* OP가 있나?
		* 각 능력치 공급량이 적당한가?
		* 대표적인 능력치 조합의 밸런스가 적당한가?
	* 국가별 방향성
		1. 한국 - PvP 중심
			* 전투 스타일 : 모두 다 딜러, 특성으로 직업별 차이 둠, 화려한 액션, 쉬운 조작
			* 성장 구조 : 친숙한 모델, 아이템 재활용 구조
			* 핵심 장비와 메타 : 장비를 바꿔가며 싸우도록 하고, 전투력 높은 애만 이기지 않도록 하자
			* 전투력 공식 : 뻥투력을 막기 위해 실제 피해량 공식과 비슷하게 전투력 공식을 만듬 
			* But…
				* 장비 교체 실패  : 메타 고정, 능력치 인플레 시작, 무기 스킬도 장비에 고정되어 버리게 됨
				* 레벨 허들 : 컨텐츠 소모 속도가 너무 느려 유저 이탈
				* 여전한 뻥투력 현상 : 효율 좋은 몇몇 능력치에 집중하기 시작 -> 선호 세팅 고정, 장비 교체 실패
			* 이러한 문제들을 라이브 서비스 하며 꾸준히 개선하는 중
		2. 일본 - PvE 중심
			* 뻥투력 완화 - 능력치 별로 전투력 반영 팩터 설정 후, 더하기(직관적으로) -> 단, 수많은 테스트를 거침
			* PvE 전용 속성 적용 -> 속성 장비 여러개 키우는 형태
			* 스킬을 장비에 독립적으로 설정
			* 레벨 허들 삭제
			* But…
				* 계단식 성장 : 장비 재활용에는 좋으나 리텐션에는 분리
				* 수직 성장 구조의 문제 : 일본은 수평 성장 구조가 지배(여러 게임을 접었다 복귀했다를 반복)
				* 애매한 속성 : PvP가 기본 컨셉인데, PvE 컨텐츠인 속성은 당위성이 부족
		3. 글로벌
			* 특화형 캐릭터 : 장비만으로 메타를 바꾸는 게 아니라 룬으로 스탯을 특화시키게 함 -> 장비에 비해 교체 비용이 적음
			* 지역의 전투력 허들 변경 : 지역당 3개 -> 지역당 1개(마지막에만)
				* But…
					* 변경된 허들의 문제점 : 한번의 허들이 오히려 더 부담
	* 총평
		* Good 
			* 쉽고 재미있는 전투를 만들어냈다.
			* 캐릭터 간 전투 성능 차이가 크지 않다.
		* Bad
			* 성장 공백이 오는 구조 -> 현자타임이 오게 하면 안된다.
			* 장비 중심의 성장 구조
			* 능력치 인플레이션
			* 허들과 허들 보상의 언매

- - - -
 
### 게임 서버의 목차, 시작에서 출시까지
* 서버 개발 - 할 수 있을 줄 알았지만 할 수록 일이 늘어났다.
	* 뭘 해야할 지 전체 목록이 없었기 때문에!
1. **취미나 프로토타입이라면 보통 여기까지한다**
	1. 최초의 의사결정 
		* 서버의 용도, 장르
		* 사용자 규모
		* 통신환경(서버에서 클라 호출이 어느정도인지, 지연시간 허용 정도)
		* 데이터 손실 허용성
		* 데이터 저장소(RDB,Redis,S3 등)
		* 언어(동적타입 vs 정적타입, 빌드시간, 클라이언트의 언어)
		* 운영체제(윈도우 vs 리눅스 vs 하이브리드)
	2.  기반 구조 보강
		* 프로토콜 -> 자주 바뀌기 때문에 최대한 자동화할 것
		* DB 추상화
			* 잘못된 케이스 차단
			* 로직 자동 생성
		* 데이터 동시성
			* 낙관적 vs 비관적
			* Lock단위 -> 유저 단위
		* 데드락 -> 락 순서 강제로 해결
		* 시간 처리
	3. 게임 컨텐츠 구현
		* 서버 로직의 분류
			* 변경 대상과 노티 여부에 따라 분류
			* 최초는 싱글 프로세스로 검증, 이후 준비를 거쳐 멀티 프로세스로스케일 아웃 
		* 테스트 자동화
			* 꼭 해야한다! ->  side effect가 매우 크고, 수동 테스트로는 검증이 어려움
		* 레이어링
			* 하위 레이어 : 로직 모듈 -> 유닛 테스트로 검증
			* 상위 레이어 : 리퀘스트 핸들러 -> 통합 테스트로 검증
		* 동시성
			* 가능하면 피하자 -> 버그 가능성이 높고, 버그를 고치기도 어렵다
			* 다른 기능들을 써보자
		* 실행 성능
			* 개별 코드 성능보다 명료한 구현이 중요
			* 성급한 최적화는 만악의 근원
			* 네트워크, DB 처리는 시간을 많이 차지하므로 미리 최적화해두면 좋음
		* 도메인 언어
			* 프로그래머의 업무를 단순화 함
		* 경제 버그 예방
			* 게임 서비스 운영에 치명적
			* 절차, 시스템을 통한 예방 필요

2. **상용 서비스 혹은 대규모 서비스에 필수적**
	1. 스케일아웃
		* 목표 동접 / 가입자 수
		* 봉투 뒷면 계산법  -> 간단한 추정
			* 스케일을 확인하기 위한 절차
		* 간이 부하테스트
			* 서버 한대가 커버하는 성능 지표를 측정
		* 게임 서버 분할
			* 로드 밸런싱
			* 무중단 업데이트
			* 유저간 상호작용
			* 가장 쉬운 건 Stateless
				* 지연 시간 길어지는 단점
		* 유저간 상호작용
			* Stateless 서버
				* Redis pub/sub 고려
			* Stateful서버에서 유저간 상호 작용
				* 서버간 통신
				* 채널 이동
				* 뒷단 서버
		* DB분할
			* 수직 분할 : 용도별,
				* 트랜잭션이 불편
			* 수평 분할 : 유저별로 분할
				* 탐색불편
					* 단순 나누기
					* lookup
			* 분산  트랜잭션
				* 분산 락을 이용하면 간편
		* Redis 분할
			* 트랜잭션으로 못 묶으니 수직 분할 적극 적용
	2.  출시 준비
		* 상당수 요구 사항이 개발팀 외부에서 발생 -> 커뮤니케이션이 중요
		* 런칭 시기 외에는 안하는 생소한 업무 -> 일정 예측 어려움
		* 개발 도메인 변경, 대외 업무 비중이 높음
		* 과소평가 하기 쉬움 
		* 매니징
			* 관리자가 실무에 매몰되면 안됨
			* 모든 일 다 할 수 없다 -> 우선순위 정하기
	3.  무점검 스케일아웃
		* 출시 피크 -> 유저수가 는다고 점검 걸면 평점테러
		* 게임 서버
			* 오토 스케일 적용은 기본
			* 부하가 너무 몰리면 미리 수동으로 스케일 아웃 해야함
		* 수평 분할된 저장소
			* %n 분할은 나중에 확장 어려움
			* 룩업 분할은 성능을 약간 희생하지만 쉽게 확장
			* CenterDB
				* 장비 설정을 중앙에서 관리
	4. 부하 테스트 
		* 서버군 : 실 서버와 비슷한 서버로(실 서버의 최적값을 찾기 위해 하는 거니까)
		* 더미 클라이언트 : 유저 행동과 유사한 클라이언트를 만들어서
			* 테스트 시나리오
			* 요청 비율 산정
			* 클라이언트 군
		* 부하 패턴 : 목표 동접 이상의 부하를 줘서 테스트
			* 신규 가입, 로그인, 높은 동접 등
			* 예상되는 성능 취약점에 부하 집중
			* 빠진 것 없이꼼꼼히 확인
			* 대기열의 부하로 테스트(목표 동접 * n)
		* 문제 확인
			* 사업팀 : 최대 동접, 가입가능 유저수, 서버 비용
			* 인프라팀: 서버구성, DB 최적화, 로그, 장애 안정성 등
			* 개발 팀 : 대규모 상황에서의 로직 오류, 응답속도, 운영 인프라
		* 문제 해결
			* 발견되는 문제를 고치면서 테스트를 계속 진행
			* 새로운 문제가 계속 출현 -> 출시일은 정해졌으니 강행군이 필수가 되버림
		* 일정
			* 준비되면 가급적 일찍 시작해야 함

3. 더 안정된 라이브 서비스를 위해 필요한 것들- 
	1. 장애 안정성
		* SPOF(단일 장애 지점)
			* 장비 다중화로 우회접속
			* 장비 장애시 곧바로 예비 장비로 대체
		* 목표 및 설계
		* 다운타임 최소화
		* 장애 여파 최소화 -> 외부 서비스 장애에 항상 대비할 것
		* 장애 복구 시간 최소화 -> 인프라 복구후에 전체 기능이 자동 복구
			* 페일 오버 기능 활용
			* R/W 재시도, 연결 끊고 재연결 자동화
			* 연속적으로 실패한 로그 데이터는 2차,3차 저장소로
			* 쓰기 실패한 데이터는 서버 재기동시 처리
		* 데이터 정합성 보장
			* Idempotent설계
			* 모든 데이터 기록은 원자성을 보장
			* 데이터 기록과 로그 기록의 정합성은  eventual consistency 보장
		* 테스트
			* 로컬 테스트 불가
				* 부하 테스트 기간에 병행해서 하는 경우가 많음
	2. 예측 실패 대비
		* 서버군 분리
		* 대기열 서버 -> 굉장히 까다로운 요구조건이 필요함
		* 차단 스위치 : 패치 없이 서버에서 특정 기능을 끄거나 추가 입장을 제한하는 기능
	3. 출시 이후
		* 누락된 테스트, 계획에 없던 추가 기능, 버그 고치려다 생긴 버그, 해킹 시도
			* 전반적인 툴과 경험이 부족, 문제 분석과 데이터 분석 어려움, 소수의 베테랑에 의존하는 경향
		* 패킷 로그 조회 
			* 장기간 보관과 검색 용이성이 트레이드 오프 관계기 때문에 용도에 맞는 설계 필요
		* 데이터 분석 -> 외부 분석툴도 도움은 되지만 결국 내부 데이터 접근이 필요
		* 장애 대응
			* 사고 사례를 잘 기록하는 것의 중요성
		* 세대 교체 준비
			* 시니어, 베테랑에 의존하면 나중에 큰일난다
	 
- - - -

### 어머님,  A/B 테스트를 댁으로 들이십시오
* 구매시간 제한이 있는 초보자용 패키지 : 시간을 얼마나 설정할 것인가?
	* 첫 구매는 이후 구매의 마중물!
* 기획자들은 각자 타당한 이유로 다양한 의견을 제시한다. -> 실험으로 증명해야 된다.
	* 개별적으로 실험을 해본다면? -> 실험의 조건을 동일하게 맞추기가 너무나 어렵다
	* 그래서 **A/B 테스트** 도입!
* A/B 테스트 : 서로 다른 N가지 경우를 실험하기 위한 통계적 디자인 패턴
* 테스트 기획시 고려 요소
	* 최상위 의도 -> 이 실험을 통해 개선하고자 하는 것은 무엇인가?
	* 유의미한 차이 -> 각 케이스가 어느정도 차이가 나야 의미있게 받아들일 것인가?
	* 실험대상 ->
	* 그룹의 개수 -> 대조군 포함 최소 2개 이상
	* 실험기간 설정 -> 최소한의 비즈니스 사이클을 포함해야한다.
* 다양한 유저들 중에서 -> 일부를 뽑아 -> 각 그룹에 배정 -> 실험 기간동안 기다린다 -> 유의미한 차이를 나타내는 그룹이 있는가?
* 실험군 나누기
	1. 그룹의 크기를 균등하게 배분해야 한다.
		* 로그인 하는 순서대로? -> 로그인 순서 기록, 실험 수가 늘어나면 일반화가 어려움
		* 유저를 특정 숫자로 매핑 -> 해시함수(MD5,SHA-1등) 이용하고, 해시값을 기준으로 그룹 배정
			* 구매력 좋은 유저들이 한 그룹에 몰린다면?
	2. 각 실험군들이 동질해야 한다.
		* 동질해야하는 성질을 정한다 -> 국가분포, 스테이지 도달률, 과금 비율, 레벨 분포
		* 실험군이 통계적으로 동질한 지 검증한 후에 실험을 진행
* 여러 실험 동시에 하기
	* 2가지 실험이 동시에 적용되면 실험이 복잡해지고 오류 가능성도 높아진다.
	* 각 실험이 독립적으로 이뤄질 필요가 있다.
		* 실험의 적용 범위를 그룹들의 범위로 설정
	* 기존 실험군의 해시값을 그대로 쓰면 특정 실험군이 누락된다
		* salt를 넣어 실험마다 별도의 기준을 적용하도록 설정
* A / B 테스트 플랫폼 만들기
	* 게임 개발자가 쉽게  A/B 테스트 기능을 사용할 수 있어야 한다.
		* 기존 플랫폼에 A/B 테스트 기능을 탑재한다. -> DevPlay
* 실험 결과
	* 해석 
		* 직관적으로 -> 설득력이 떨어짐
		* 통계적으로 -> 직관으로 보이지 않던 부분을 드러나게 해
	* 결론 : A/B 테스트는 통계를 근거로 합리적인 의사결정을 할 수 있는 방법론!
 
- - - -

### 그치만 이렇게 하지 않으면 A/B 테스트 시켜주지 않는걸 - 실시간 A/B 테스트 플랫폼 개발기

* 설계 -> 구현 -> 활용, 주로 설계와 구현에 중점
* 반년 전에 하고 싶었던 것 : 머신러닝, 새로운 가치를 만들어 내는 프로젝트 -> A/B테스트를 통해 서비스에 적용
	* 실제로 하게 된 것 : A/B 테스트 플랫폼 개발
* A/B 테스트 : 두가지 케이스를 각 사용자에게 랜덤으로 제공하는 실험을 통해 이용자 경험을 객관적으로 측정하는 것 -> 데이터 기반 의사 결정 기반 제공
* 설계
	1. 로그
		* 로그가 없다면? 
			* 정확도가 떨어져요 -> 실험을 오래 하면 됩니다(더 많은데이터)
			* 서비스에 영향을 미칠까 불안하다 -> 실험군 비율을 줄이면 되지
			* 데이터 파이프라인이 없어요 -> 직접  ETL하면 된다
			* 로그가 없다 -> 노답… 
		* 로그 처리
			* 캐고 -> 수집하고 -> 분석
			* 구글이 모든 것을 제공해주만, 그대로 사용하지는 못했다.
				* 대신 구글의 설계를 많이 참조했다.
	2. 직접 만드는 데이터 파이프 라인
		* 요구사항
			1. 실시간
				* 기본적인 요구는 배치 프로세싱으로 해결
				* 긴박한 요구느 실시간 스트리밍으로 해결
			2. 확장 가능한
				* 사용자 수가 늘어나면 데이터 단위도 커진다
				* TB단위정도 가면, 서버 크기를 늘리는 것으로는 해결이 안된다.
					* 서버를 늘려야 된다
					* 분산 처리가 필수
				* 실시간 스트리밍 + 분산 처리 = ?
					* 하지만 언제나 누군가가 답을 만들어 놨다 -> 아파치 Flink
					* 스파크와 비슷하지만, 스파크는 배치용으로 설계된 것
			3. 24/7 
				* 개발자의 밤잠을 설치지 않으려면? : 보급!아마존!
					* 장애대응은 완전관리형 서비스
					* 서버관리는 서버리스 서비스
					* 모니터링은 모니터링 서비스
					* 나는 돈만 내면 된다.
	* 현재
		* 많은 부분을 자동화, 적절한 시각화
		* 남은 문제 : 비용 최적화, 배포 자동화, 운영도구 개발 등…
	* 미래
		* Multi-Armed Bandit -> 결과를 실시간으로 피드백해서 적용
		*  추천 시스템 -> 선제적으로 유저에게 추천 
		* 단순한 측정 플랫폼을 넘어 가치있는 컨텐츠를 학습해서 제공!
	* 결론
		* A/B 테스트, 해야 한다. 대신 잘해야 한다.
		* 벤치마크는 부끄러운 것이 아니다 -> 구글이 하는 것은 다 그럴만한 이유가 있다
		* 모두가 쓰는 기술에는 이유가 있다. -> 남들이 미리 해둔 거 잘 써야 한다
		* 사람이 없으면 돈으로 -> 비싼 서비스는 비싼 값 한다.
		* 하늘이 무너져도 날로 먹을 방법은 있다
- - - -

###  <야생의 땅: 듀랑고>, 조직 문화와 라이브 개발 프로세스

* 프로젝트 매니저가 하는 일
	1. 버전별  작업 목록과 진행을 관리
	2. 정보가 원활히 공유 될 수 있도록 함(Jira 사용)
	3. 조직과 개발 과정에서의 각종 문제해결
* 듀랑고 팀의 조직 문화
	1. 자유롭고 개방적 -> ‘무엇을 하고 싶으세요?”
		* 누구나 자유롭게 자기 의견 표현 가능
	2. 엄청나게 소통함 - 열심히 말하고, 기록하고 듣고
		* 매일 슬랙 1만 단어
		* jira 백로그 매달 1000개
		* 이런 걸열심히 읽는다
	* 좋게 보면 아이디어가 샘솟고, 나쁘게 보면 어디로 튈 지 모른다.
* 라이브 서비스의 요구 조건
	1. 일정 준수
	2. 복잡한 협력관계
	3. 서비스 안정성
* 어떻게 하면 자유로운 문화를 유지하면서 안정성도 놓지 않을 수 있을까?
	1. 넘쳐나는 정보량과 의사의 문제 -> jira
	2. 안정성과 예측 가능성 문제 -> 스크럼
		1. 할 일 후보를 모은다
		2. 작업 우선순위를 정한다
		3. 개발 주기 내에 할 일을 정한다
		4. 2주 동안 정해진 일을 한다.
		5. QA 및 패치 노트 작성
		6. 실제 업데이트
* 듀랑고 팀의 라이브 프로세스
	1. 할 일 후보 모으기
		* 모두 jira에 등록
		* 팀 모두가 등록 가능
		* 다양한 할 일의 출저
	2. 작업 검토
		* 작업 난이도, 작업 시간등을 전문가에게 검토
		* 각 분야의 전문가들이 초기 단계에서 피드백
		* 각 작업들이 카드 하나로 할당되고 각 일의 상태를 쉽게 알 수 있다. 
	3. 다음 업데이트에 할 일 결정
		* 2주마다 정기적으로 일감 회의 개최
		* 검토가 끝난 일들이 후보가 됨 
		* 우선순위, 가용 인력을 보고 가능한 작업만큼만 넣어 보냄
		* 우선순위는 게임 디자인 팀의 의견을 중시
		* 작업력 : 가용 인력 * 가용 영업일 * 50~80%
		* 선정되지 못한 일은 다음으로 미루거나 너무 미뤄진다 싶으면 보류 처리
	4. 개발 시작 준비
		* 일감 회의 결과 정리 -> 담당자 배정
		* WBS 플러그인으로 작업들을 구조화해서 볼 수 있다.
			* 버전 -> 카테고리 -> 작업 -> 부작업
		* 스크럼 보드를 통해 개발 진행상황 실시간 체크 -> 마감일 전에 해당 스프린트 내의 모든 일이 완료가 되어야 함
	5. QA 및 패치 노트 작성 준비
		* 개발 마감되면 해당 업데이트용 브랜치 분리 -> 더 이상 일이 추가되지 않도록 함
		* 해당버전 Jira작업들의 담당자를  QA로할당 -> 발견된 버그도 jira에 등록후 처리
		* 프로젝트 매니저는 이를 수합해 패치노트 작성
	6. 업데이트
* 효과가 있었나?
	* 관리 측면에서 매우 좋음
		* 모든 정보가 jira로 모이므로 누락이 줄고, 일은 복잡해도 생산성은 오히려 늘었다.
	* 활발한 의사소통은 여전하다.
		* 다만 업무상 전문화, 분업화는 점점 진행중
	* 리드타임(일감 의뢰 -> 배포 시간)은 늘었다 -> 대신 안정성은 좋아졌다.
	* 사람들의 반응은 갈린다
		* 디자인 팀은 일감이 선정되지 않는 아픔이 늘었다
		* 아트,개발팀은 행복도가 늘었다
	* 1년 가까이 안정적으로 시행 중
* 앞으로의 방향
	* 현재의 개발 프로세스는 수많은 업데이트의 결과 -> 지금도 변화중
	* 유관 부서들도 점차 함께 하는 중 -> Jira로 일원화
* 결론 : 자유와 관리, 두마리 토끼 잡기 가능
* 프로젝트 매니저로써의 보람 : 동료들과 조직의 문제를 푸는 기쁨, 스트레스도 많지만 행복한 직업
* Q&A
	* 이상적인 PM 비율 : 개발팀 10~15명당 PM 1명
	* 마찰은 많을 수 밖에 없다. -> 뒷단에 있는 사람의 의견에 힘을 실어주자
	* 조직 규모의 단위 : 20 / 50 / 100 … 20명 이하면 굳이 jira까지 쓸 필요는 없다
	* 작업 규모 산정 : 작업을 최대한 작게 쪼개라

- - - -

## 3일차

### Interpretable Recommender System 개발 사례연구

* 개발 사이클 : 로직(Model) -> Serving API -> Service App -> Data Collection -> Data Processing 의 반복 
*  Interpretable : 기존 머신러닝 모델(블랙박스)을 해석하고자 하는 노력 
	* 추천 시스템은 머신러닝 방법론을 사용
		* 전통적 머신러닝 방법론 : 트레이닝, 테스트 row 쪼개고, 독립변수와 종속 변수를 쪼갬
		* Collaborative Filtering : 안쪼갠다
* 머신러닝이 왜 어려울까?
	1. 모델이 어렵다 : F(x)가 어렵다 -> F(x)를 보여주자
	2. 데이터가 어렵다 : 차원이 너무 높다 -> 3차원 이하로의 시각화!
* 솔루션
	* Manifold(다양체) : 고차원 공간에 내재한 저차원 공간
	1. 시각화
		1. 데이터 시각화
		2. 모델시각화
	2. 동작방법
		1. Interative
		2. Reactive하게
	* 솔루션 예시
		* Manifold(다양체) : 고차원 공간에 내재한 저차원 공간
			1. Interpretable Methods 
				1. LIME(Local Interpretable Model-agnostic Explanations)  : 데이터를 쪼개서 국소적으로 해석해서 각 부분이 어떻게 
				2.  DALEX -> 다른 변수를 최대한 통제해서 단일 변수의 변화의 흐름을 얻음
				3. Shapely Value
				4. Plotry -> 모델 시각화
				5. shiny
		-> 위 솔루션들을 조합하자!
* 추천 시스템 : 특정 사용자가 관심을 가질만한 정보를 추천하는 것 -> 중요하는 것은 피드백!
	* 매출이나 클릭율 상승에 선구적 역할
	* 유저의 행동을 유도할 당근의 역할 -> 오버워치의 추천 시스템
* 게임에서의 시스템 개발 난점 : 게임에서 어떻게 피드백을 얻지?
	* 명시적 피드백(평점,좋아요/싫어요)
	* 암시적 피드백(구매행위, 활동)
	* 게임에서는 채널이 모호하거나 너무 다양하다
		* 게임 내 채널 : 상점, 길드,로비…
		* 게임 외 채널 : 웹사이트, 앱…
	* 무엇을 피드백으로 할 지는 그때그때 다르다
* **오늘의 사례 : 피드백이 불명확하지만 데이터가 많은 경우**
	* 질문 : <마블 배틀라인> -> 타노스를 무찌를 덱(12장)을 어떻게 만들 수 있을까?
		* 덱을 어떻게 평가할 수 있을까?
	* 방법론 : word2vec ->  NLP(자연어처리)기술을 가지고 card를 벡터로 바꾼다.
		* word embedding : 비슷한 분포를 가진 단어들은 비슷한 의미를 가질 것이라는 가정
		* CBOW(Continuous bag of words model) -> 연속적인 여러 주변 단어로 부터 중심 단어 예측
		* Skip gram : 중심 단어로 부터 주변 단어 예측
		* ex) king - man + women = queen
	* Model : 카드를 순서대로 넣었을때 다음 카드를 예측
		* 특정 카드를 중심 카드로 설정 
		* window를 움직이며 전체 리스트에서 input 세트를 생성
	* word2vec은 NLP의 방법론이지만 많은 응용이 있음 -> item2vec으로의 확장 가능!
	* 카드 벡터를 알면 특정 카드와 유사성을 가진 카드를 결과를 얻을 수 있다. 
		* 고수가 가진 카드와 하수가 가진 카드를 비교해서, 고수는 있고 하수는 없는 카드를 비교해서 알려준다.
	* 주의! 일부분을 본다고 전체가 커버되지는 않는다.
		* Ensemble Method : 여러가지 모델(ML,통계 등)을 합께 이용하는 것
		* 앙상블 -> A/B테스트 조건 계산 -> 백엔드 서버 API -> 게임 서버
	* 그리고 계속되는 최적화…
* Research Playground 
	* DeepCTR 리서치
	* Recommendation System(bible)
	* Kaggle
	* Kdnugget

- - - -

### SilvervineUE4Lua - UE4에서 Lua 사용하기

* UE4 BluePrint
	* 장점
		1. 배우기 쉽다
		2. 사용법이 간단하다
		3. 작업 진행 속도가 빠르다
		4. 데이터 흐름, 상태 기술이 편하다
		5. 셰이더 프로그래밍, 애니메이션 상태 기계 프로그래밍 할 때 유용
	* 단점
		1. 복잡도 관리가 어렵다
		2. 공동 작업이 어렵다 -> 바이너리 형식이고, 베타적 체크아웃이라서
		3. 코드 리뷰가 어렵다 -> 변경점 찾기 불편하다
		4. 디버깅이 어렵다
	* 해결 방법은?
		1. 안쓴다
		2. 텍스트 스크립트 언어(Lua)를 사용한다
			* 사례
				* UE4 ScriptPlugin -> 레퍼런스, 업데이트 멈추고 문서 없어 사용하긴 어려움
				* SkookumScript -> 자체문법
				* Unreal.js -> NC에서 만든
				* UE4 Python Editor Script Plugin -> 문서화 되어 있음, 에디터 스크립트라 런타임에 쓰려면 개조가 필요
				* Mono UE -> 오픈 소스, 좋은데 1인 개발 제품이라 불편한 부분이 많다.
				* UnrealPythonScript
				* unreal.lua
				* sluaunreal 
	* BluePrint 지옥 탈출하고싶다
		* C++로 탈출 시도 -> 작업량 많고, 실수 가능성이 높다
	* 목표 : 복잡도 낮추는 것
		* 방법 : 텍스트 스크립트 언어 도입 -> Lua선택 (좋아서 쓴 건 아니고 익숙해서)
	* 자체 제작 결심한 이유
		1. 다른 플러그인은 스크립트 자유도가 너무 높다
		2. 문서화 및 코드 품질이 중요(텐센트 껀 중국어라…)
	* SUE4Lua 특징
		1. 스크립트를 소스코드와 동등하게 취급
		2. 디버깅 도구 제공(VSCode Extension)
		3. BluePrint 함수를 Lua로 쉽게 구현하고 연결할 수 있다. -> 디스패치
	* 사례분석
		* AI 설정을 기존 텍스트에서 Lua 스크립트로 변경
		* Lua로 미션스크립트 구현
		* 엔지니어와 디자이너 모두 Lua 사용 -> 블루프린트와  C++의 장점만 살림
		* 복잡하고 거대한 BluePrint 함수 정의를 Lua로 대체 -> C++에는 선언만 남기고, BluePrint로는 호출 -> 쉽게 변경할 수 있어서 편리함
	* 스크립트 가이드
		* GitHub에 문서화
		* 코딩 컨벤션 : UE4 코딩 컨벤션 따름
		* 개발 빌드 한정으로 Lua 스크립트가 바뀌면 바로 적용 가능
		* 팁 
			* Lua 상태 변수는 따로 격리하기
			* UE는 함수, 속성 이름에서 대소문자를 구별하지 않기 때문에 주의해야 한다!
			* BluePrint의 디스플레이 함수와 실제 이름이 다르기 때문에 주의할 것
			* Lua안에서 UObject에대한 강참조를 만들지 않는다
	* 설계 리뷰
		* Lua 버젼 : 5.3.4(가장 보편적인 버젼인  5.1.5를 쓰면 일부 기능 지원 불가)
		* Lua JIT 지원 안함
		* 플러그인 내부에  Lua 소스코드가 있음
		* luasocket 및 op_halt 패치가 적용되어 있다.
		* 파일 로더 클래스 세분화 -> 쓰는 사람에 따라 사용하는 로더가 다름
		* UE4 ScriptPlugin 모듈과 동일하게 구성
		* SUE4LuaEditor : VM 팩토리 클래스가 있고, VM을 에디터에서 쉽게 지정 가능
		* 스태틱 바인딩 코드 생성 ->두개의 거대한 .inl파일 생성
			* 리플렉션보다 당연히 빠르다
			* 실행속도가 빠른 대신 빌드 속도가 느리다
			* 비활성화 가능
		* 디폴트 파라미터 테이블
		* lua 객체를 C++에 저장할 수 있다
		* 컨테이너 객체를 직접 넣을 수는 없으나 함수 파라미터 등으로 넣어서 우회할 수있다.
		* 각종 편의성 기능 추가 
	* 요약
		* BluePrint 의 단점 보완하기 위해 Lua사용
		* 앞으로도 많은 도움이 필요

- - - -

### <하스스톤> 강화학습 환경 개발기 - 0티어 덱을 만들기 위해 떠나는 모험
* 강화학습을 하기 위한 환경을 만드는 과정
* 왜 하스스톤인가?
	* 연습모드에서의 컴퓨터 AI가 이해할 수없는 플레이를 한다.
	* 알파고, 알파스타 -> 하스스톤도 그렇게 되지 않을까?
* 목표
	* 영리한 플레이
	* 0티어 덱(승률 60퍼 이상)
	* 카드 추천
* 강화학습 : 아이가 첫 걸음을 떼는 과정과 비슷
	* 사전 지식 없는 상태에서 학습
	* 자신이 놓인 환경에서 자신의 상태를 인식 후 행동
	* 환경은 보상을 주고 다음 행동을 하도록 만듬
	* 보상에 따라 더 좋은 행동을 습득하게 됨
* 알파고와 알파스타의 차이 
	* 완전한 정보 vs 불완전한 정보
	* 하나의 컨트롤 vs. 수많은 컨트롤
* 하스스톤의 상황은?
	* 내 정보마저 불완전하다 -> 상대 덱이나 패에서는 물론 내 덱에서조차 뭐 나올지 모른다
	* 무작위 카드가 많아 결과 예측이 힘들다
* 게임을 활용해 강화학습하는 방법
	1. 게임 회사에서 제공하는 API 사용 -> 스타2는 있는데 하스스톤은 없다
	2. 게임 후킹 -> 불법이다
	3. 게임을 직접 만들어 사용 -> 하기 싫지만 방법이 없다.
* 하스스톤 구조 분석
	* 카드 구현
		* 카드-엔티티 구조 : 카드는 순수한 카드 정보만을 가지고, 엔티티는 카드 정보를 기반으로 게임에서 사용할 수 있도록 새로이 만든 객체
		* 고려할 부분
			1. 카드 데이터를 어떻게 구할까 -> HearthStoneJSON 사이트가 있다. (거의) 모든 데이터가 있다 -> 거의에 주목! 개발 난이도를 높이는 원인
			2. 카드 데이터를 어떻게 가져올까
				* 모던 c++ JSON 파싱 라이브러리 사용
				* 문자열 형태의 데이터 -> 성능 문제로 열거체로 변환할 필요성 있다.
				* 열거체 정보는  파이썬으로 된 다른 하스스톤 관련 프로젝트에서 가져왔다.
				* 문자열-열거체 간 변환을 지원해주는 라이브러리 사용 -> better enums
			3. 카드 효과를 어떻게 처리할까?
				* 미친듯이 다양한 효과의 종류
				* 거의 모든 데이터의 맹점
					* 카드 데이터로 카드 효과를 읽어 낼 수가 없다!
					* 너무 많은 카드 개수, 또한 수집 불가능한 카드들의 존재
				* 솔루션
					1. 데이터를 읽어 자동으로 효과 처리 코드를 만들기 -> 선행연구가 있긴 한데, 쉽지도 않고 100% 되지도 않는다
					2. 직접 다 구현한다. -> 힘들지만 확실하다, 효과 없는 카드도 많아서 수고가 좀 줄어든다.
				* 죽음의 메아리 / 전투의 함성 구현
					* ITask를 상속하는 구체적인 Task를 만든다.
					* 이러한 Task를 한 개 또는 두 개 이상 실행 가능하게 하는 함수를 만든다.
					* 이렇게 만들어진  Task를 등록한다
				* 공격 구현
					* 공격전 : 공격 가능 상태 확인, 타겟 유효성 확인
					* 공격시 : 특수 효과,
					* 공격후 : 파괴처리
		* 게임 진행 구현
			* 게임 진행 페이즈 설정
			* 각 페이즈 별로 처리할 내용들을 구현
	* 강화학습 환경 개발
		* 우리의 목표는 AI가 게임을 하게 만드는 것
			* AI가 행동을 하기 위한 통로 -> 정책 클래스를 설계 후 만들어 적용
			* AI의 결정이 게임에 적용이 되어야 한다. -> pytorch C++ API를 사용하고 정책을 정해 적용
	* 정리
		1. 게임에서  API제공하면 좋은데, 없으면 직접 만들어야 한다.
		2. 게임 다 만들면 강화학습을 하기위한 밑작업을 해야한다
		3. 이후 게임과 데이터를 변화해야 한다.
- - - -

### 구성원 역량강화 3년 - 조직의 습관은 사업전략과 일치해야 한다

* 나, 그리고 각 조직원들에게 가장 중요한 자질은 무엇인가?
* 발표자는 고객센터 담당
	* 특별한 기술 요구하지 않고, 스펙과 경력에 무관
	* 하지만  생각보다 다양한 역량이 요구된다
* 고객센터에 필요한 역량-> 각 항목 아래에도 상세 
	* 기반지식 및 노하우
	* 마인드 및 태도
	* 커뮤니케이션
	* 인프라 / 정책 / 프로세스
* 하지만 구성원들 개개인에게만 맡길 수 없다 -> 다같이 하자
* 해결과제
	* 무엇을 핵심 역량으로 볼 것인가? 
		* 모든 역량을 다루기는 사실상 불가능
		* 시간 * 구성원수 = 비용
		* 핵심 역량의 조건
			* 보편성 -> 이 일을 하기 위해서 필수적인 것들 -> 게임이해
			* 특수성 -> 우리만이 보여줄 수 있는 것 -> 글쓰기
			* 지속가능성 -> 서비스하는 제품이 바뀌더라도 유지될 수 있는 문화 -> 공유 문화
	* 어느 수준가지 끌어올릴 것인가
		* 드라이퍼스 모델 -> 많은 사람들이 고급입문자~중급자에 머무른다.
		* 전문성을 높이기 위해서는 -> 짧은 주기의 피드백 필요 
* 습관화 하기
	* 습관화 방향
		1. 실무 연관성
		2. 측정 가능성
		3. 구체적인 목표
		4. 최적화
	1. 게임 이해도
		* 목표 : 이해도에서 고객을  능가하기 어렵고, 개발자의 의도를 이해하기도 어렵다. -> 고객 경험을 따라가는 쪽으로 가자
		* 솔루션 : 게임을 이해하기 위해 최소한의 플레이 기준 제공 -> 플레이 정도와 지식,문제해결 측면이 어느정도 일치하는 경향
			* 플레이 시간과 이해도가 일치하지 않는 경우가 발생 -> 플레이어의 입장이 아니라 서비스 입장에서 할 수 있도록 해야함
			* 게임을 안하는 사람에게는 아무것도 기대할 수 없다.
		* 결과 : 90% 이상의 사람이 Normal 정도의 이해도, 표준 답변율 상승, 오류 비율 감소
		* 추천 : Monthly 미션(월간 이벤트 참여), 게임 대회(조직 분위기에 긍정적 작용)
	2. 글쓰기 역량 -> 의사소통능력
		* 목표 : 고객이 원하는 글을 쓰고 검토 없이 발송 가능한 상태
		* 현상황 : 고연차 사원은 습관적 사과, 신입사원은 부적절한 문체 -> 고강도 민원은 높은 사람들이 해왔고, 가이드가 없었기 때문에 훈련할 기회가 없었음
		* 해결책 : 고강도 민원에 대한 지속적인 테스트, 사례 분석과 전파
		* 결과 : 더 정중한 문체러, 회사의 입장도 충분히 대변하는 글
		* 인사이트 
			* 조직 전체의 이슈 민감도를 높게 유지
			* 고강도 문의 경험 빈도를 높여야 한다.
			* 좋은 내용이 있어야 좋은 답변이 가능하다.
		* 해결책2: 외부 글쓰기에 관련된 시험을 하면 어떨까? -> 구성원들에게 불필요한 공부를 시키지 않아야 한다
			* 한국실용글쓰기 시험이 좀 더 직무 연관성이 높아 글쓰기 수준 측정 도구로 적합 
		* 결과2 : 자격 취득률 86%(평균 합격률 55~56% 상회)
		* 의미
			*  공인된 측정 도구를 활용한 조직 수준 진단
			* 업무를 위한 최소한의 역량 확보
			* 자부심 상승
		* 추천 : 서비스 글쓰기 테스트(교육효과 뛰어남), 한국실용글쓰기 검정시험(관심있는 조직 & 개인에게 권유)
	3.  공유문화
		* 탑다운 : 지향점 공유
			* 조직과 개인의 목표 일치
			* 고객 중심 사고를 위한 메세지
		* 바텀업: 공유의 장 마련
		* 칭찬
			* 구성원의 사기 = 서비스 품질로 직결
			* 고객의 칭찬 = 조직의 칭찬이 되도록
* 역량과 서비스 품질의 상관관계
	* 역량의 상승이 정말 서비스 품질 향상에 도움이 되었는가? -> 가설검증 필요
		* 다 잘하면 성과가 물론 높다
		* 글쓰기를 잘하면 평균 만족도가 높다 -> 설령 원하는 걸 못 얻었어도
		* 서비스의 가장 기본은 게임 이해다
* 결론
	* 개인의 역량을 키우기 위해서 반드시 조직적인 뒷받침이 되어야 한다.
	
- - - -

### 실버바인 대기열 서버 설계 리뷰

* 대기열을 왜 만드나
	* 한 서버가 수용할 수 있는 인원은 제한적
	* 서버 용량을 늘리는 건 비용이 많이 듬
	* 예전에는 서버 선택권을 유저에게 줬으나, 지금은 마치 단일 서버처럼 동작하게 만들어야 함
	* 못 들어가는 사람을 내치는 것보다는,  기다리게 만들자
	* 그럼 모든 게임에 대기열을 넣으면 좋지 않아?
		1. 사용자가 대기열에서 천년만년 기다리지 않는다
		2. 대기열은 예측 불가능한 상황을 대비하는 임시방편
			1. 런칭이나 주요 이벤트 직후
			2. 구조적으로 스케일링이 쉽지 않은 경우(MMORPG) 
	* 목표
		1. 게임 서버에 추가 부하가 없어야 한다 -> 별도 서버, 망 분리
		2. 게임 서버보다 훨씬 안정적이고 빨라야 한다
		3. 선입선출 -> 대기중인 사용자 구분
		4. 기다리는 동안 사용자에게 유용한 정보를 제공해야한다. -> 대기열 서버 전체가 공유하는 상태가 필요
* 어떻게 만드나
	* 목표
		1. 게임 서버에 추가 부하가 없어야 한다 -> 별도 서버, 망 분리
		2. 게임 서버보다 훨씬 안정적이고 빨라야 한다
		3. 선입선출 -> 대기중인 사용자 구분
		4. 기다리는 동안 사용자에게 유용한 정보를 제공해야한다. -> 대기열 서버 전체가 공유하는 상태가 필요
	* 상태 관리 전략
		1. 모든 대기자를 다 기록한다.
			1. 랜덤 태그 발급 가능
			2. 중간에 빠져도 알릴 방법이 있음
			3. 대기자 수 정확히 추산 가능
			4. 상태가 크고 동기화하기 어렵다
		2. 가장 오래된 대기자를 기록한다.  -> 실버바인에서는 이 방식을 채택
			1. 순서대로 태그를 발급해야 한다.
			2. 중간에 사람이 빠지면 문제가 될 수 있다.
			3. 대기자 수에 허수가 끼게된다.
			4. 상태를 간단하게 유지할 수 있다
	* 동작 원리
		1. 클라이언트: 서버 목록 확인
		2. 클라이언트: 대기표 발권 및 폴링
			1. 발급 순번 확인
			2. 순번 발급
			3. 발급 순번 증가
			4. 이후 입장 순번이 될 때까지 계속 폴링
		3. 게임서버; 동접에 따라 대기열 서버에 피드백
		4. 대기열 서버: 대기 종료후 입장권 발급
		5. 클라이언트 입장권으로 게임서버 입장
	* 게임 서버가 해야할 일
		1. 대기열 서버가 발급한 입장권을 검증해야 한다
		2. 입장권의 사용 여부를 확인해야 한다. -> 재사용 공격 방지
		3. 대기열 서버와 피드백을 잘해야 한다
			* 얼마나 순번을 올려야 하나?
				* 한계 동접에 근접하면 증가폭을 줄여야 한다
				* 로그인은 비싼 작업이기 때문에 무작정 들일 수는 없고, 적게 올리자니 사용자가 불편해 한다.
			* 피드백 = min(남은 동접 *피드백 비율,시간당 허용 진입)
	* 상태를 줄여라
		* Http는 대표적인 stateless 프로토콜
			* 대기표를 매번 보내 확인
			* 대기표를 관리할 권한은 클라이언트에 넘어감
		* 최소한의 상태를  Redis로 관리
* 대기열이 죽으면 어떻게 되나
	* 저장소가 실패점인 경우
		* 횡분할? -> 대기순서와 진입 순서가 달라진다 -> 사용자 불만 증가
		* 대기열이 죽었을 때 게임 서버가 다르게 행동하게 할 수 있다. -> 대기열을 안 쓰는 것처럼 작동하게 하기
	* 대기열 서버가 죽을 경우 -> 서버와 클라이언트 모두 대기열 없이 작동하게 할 수 있음, 타이밍 오류 가능성
	* 네트워크 오류
		1. 게임서버-대기열 서버 네트워크 : 입장권은 발급 받지만 게임서버가 검증하지 않게 됨
		2. 클라이언트-대기열 서버 네트워크 : 당연히 접속 안된다. 사용자에게는 그저 네트워크 오류로 보인다.
* 더 잘 만들수는 없을까?
	* Redis에 들어가는  명령을 모아서 한꺼번에 할 수 없을까?
		* 중간 서버를 둘 수도 있겠지만, Redis가 인메모리 DB라 로드 밸런싱말고는 크게 기대하기 어렵다
		* 서버에서 합쳐주자! -> 다른 서버에는 보통 통합 연산이 없지만, 실버바인 2는 가능하다! -> 지연을 약간 희생해서 대역폭을 대폭 늘린다.
	* 대기 시간 추정 
		* 게임 서버로 부터 피드백 받는 것은 이산적이라, 피드백을 못받을 수도 있다.
		* 대신 허용시간이 증가하는 속도를 계측 
			* 피드백이 없으면 속도가 감소
			* 피드백을 받을 때만 속도 다시 계측

- - - -

### 이세계 시나리오 라이터를 위한 스토리텔링 - 유저의 이탈을 막는 매력적인 첫 문장 작성하기

* 라이트 노벨의 전형적인 이미지
	* 실제 내용이 어떻든 편견을 가진다
* 잘못된 첫 인상이 미래의 유저를 떠나 보낸다
* 모바일 게임에서는 이 첫 인상이 더 중요하다
	* 시간이 중요한 재화
	* 무료 게임 -> 일단 무료 후 마음에 들면 추가과금하는 방식 선호
* 게이머는 어떤 첫인상을 받을까?
	* 기존 패키지 유저 
		* 사전 지불된 비용에 대한 보상 심리로 게임한다
		* 비교적 플레이 시간에 크게 구애받지 않음
	* 모바일 유저
		* 무료 게임이라 보상 심리 없음
		* 시간이 중요하기 때문에 만족 구간까지 가기 어렵다
* 게임 제작은 협력이기 때문에 소설과 달리 쉽게 방향 틀기가 어렵다 -> 각 팀 별로 요구사항 다 만족하려면 노오오력…
	* 처음에 만렙 보여주고 꿈으로 처리하고 처음부터 시작하는 전개가 흔함
* 뭐가 됐든 시나리오 라이터는 결국 텍스트로 승부본다.
* 좋은 텍스트는 어떻게 쓰는가?
	* 자주 쓰이는 문장(클리셰)를 분석하라 -> 처음에는 분명히 참신하고 좋은 문장이였다.
		1. 태초에 천족과 마족이 있었다. -> 자주 접하여 익숙한 문장
		2. 제국력 1024년 -> 유추할 수 있는 다양한 정보를 제공하는 문장
		3. 모르는 천장이다 -> 정보를 의도적으로 차단하는 문장
		4. 오니짱 하야쿠 오키나이또 -> 장르 특성을 단번에 이해시키는 문장
* 결국 좋은 첫문장이란 **유저의 흥미를 유발하는 요소를 내포하는 문장**-> 다음 문장을 읽게 만든다(Retention 상승)
* 첫문장에서 승부수를 띄웠으니, 뒷 부분은 다른 파트에 맡기고 편안하게 써내려가자
- - - -

### 코드 리뷰 실천 방안 제안

* 용어
	1. 리뷰이 : 리뷰 받는 사람
	2. 리뷰어 : 리뷰하는 사람
	3. 투표 : 리뷰하고 난 뒤 수정이 필요한 지 아닌지 체크하는 것
* 과정 : 풀리퀘 -> 리뷰 -> 투표 -> 머지
* 코드 리뷰의 장점
	* 협업적으로
		* 서로의 코드를 보고 배운다
		* 코드의 흐름을 잘 따를 수 있다
	* 좋은 코드의 면으로
		* 실수를 빠르게 찾을 수 있다
		* 더 좋은 구현 방안을 제안할 수 있다
		* 일관성 있는 코드 스타일 유지
* 마음가짐
	* 팀원에 대한 신뢰는 잠시 넣어두자 -> 서로의 책임을 다하자
	* 각자 맡은 역할에 충실해야 코드 리뷰의 효과가 높아진다.
	* 형식적인 코드 리뷰가 되지 않게 하자 -> 댓글 하나 없이 리뷰가 계속 통과 된다던지
* 코트 리뷰 보기
	1. 리뷰이 
		* 코드 잘보이게 하기
			* 코드 정리
			* 커밋 정리
				* 크기는 작게
				* 내용은 하나만
				* 메시지는 명확하게
			* 변경 내용 정리
				* 댓글로 추가 정보 제공
					* 코드를 볼 때마다 필요한 설명 -> 주석
					* 이번 리뷰에만 국한된 내용 -> 리뷰
					* 계속 추적해야 한다면 -> 이슈
			* 셀프 리뷰는 필수!
	2. 리뷰어
		* 리뷰 파악하기
			* 리뷰 요약, 설명
			* 관련 이슈
			* 리뷰이 또는 다른 리뷰어가 추가한 댓글
		* 점검사항
			* 의도대로 구현했나
			* 간단한 edge case 점검
			* 잘못 동작할 수 있는 경우 생각해보기
			* 사이드 이펙트 고려
			* 성능
		* 코드 점검
			* 같이 바뀌어야 하는 부분이 빠지지 않았는가
			* 중복 구현하지 않았는가
			* 컨벤션은 지켰는가
			* 가독성은 좋은가
		* 커밋 단위로 살펴보기
			* Diff 보기
				* 각 변경이 어떻게 연관되는시 생각해보기
		* 전체 Diff 보기
			* Diff 주변을 살펴보기 -> 같이 수정되어야 하는 부분이 누락될 수 있다.
				* 변수의 의미가 바뀐 경우
				* 주석
				* 이전에 발견 못한 실수
			* 추가된 파일은 유심히 봐야한다
				* 추가된 위치가 적절한지도 확인해 봐야한다
		* 댓글 쓰기
			* 왜 수정 필요한지
				* 어떻게는 옵션
			* 정보 제공 용도라면 말머리 등으로 따로표시
				* 굳이 안 고쳐도 된다고 인지하도록
		* 투표
			* 다 봤으면 바로 투표 -> 리뷰이가 수정 타이밍을 잡아야 하기 때문에
	3. 다시 리뷰이
		* 질문에 답변
		* 수정할 수 없거나 수정하지 않아도 된다면 이유를 답변하기
		* 놓치는 댓글이 없도록 하기
		* 댓글이 있는 위치 외에 비슷한 다른 부분도 살피기
		* 커밋 메시지 작성 -> 수정 내용 위주로
		* 댓글에 명시적으로 답변 달기 -> 수정 여부 확인 어려움
* 커뮤니케이션
	* 비동기 -> 핑퐁 횟수가 많아질수록 비효율적
		* 되묻는 질문이 나오지 않도록 명확하게 전달
		* 핑퐁이 길어질 것 같으면 직접 커뮤니케이션, 여기서 정해지면 댓글로 달기
	* 비대면 -> 컨텍스트 부족으로 딱딱하게 느껴지기 쉬우므로 최대한 친절하고 자세하게
	* 비판
		* 나에 대한 비판이 아닌 코드에 대한 비판! -> 받아들이기 쉽지는 않다
		* 코드에 도움이 되는 방향인가를 생각하기
	* 댓글을 쓸 때도 코드 중심으 -> 문제와 수정 방향 잘 생각하기
	* 커뮤니케이션 충돌
		* 리뷰이의 의견 우선 존중
		* 결론이 안나면 매니저가 중재
* 코드리뷰 왜 잘 안되나?
	* 잘 안 읽히는 코드
	* 불친절한 리뷰 설명
* 아는 만큼 보인다 
	* 언어, 프레임워크, 라이브러리, 코드 베이스에 대한 이해도가 높아야 
	* 서로의 작업에 대한 이해도가 높으면 유리 -> 너무 많이 알아도 비효율적
* 코드 리뷰 효율 높이기
	* 셀프 리뷰 꼼꼼히
	*  Linter 사용
	* 컨벤션 숙지하기
	* 커뮤니케이션 핑퐁 줄이기
* 설계 얘기하고 싶은데…
	* 설계 이야기하기는 좀 늦은 타이밍 -> 이미 시간을 많이 들였기 때문에
	* 설계 리뷰는 코딩하기 전 미리미리 하자
